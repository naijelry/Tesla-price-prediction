# -*- coding: utf-8 -*-
"""feature_engineering_model_prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D553aq0vjoDgIv0H3_DzMLnrfKHpA89f
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import xgboost as xgb
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.model_selection import train_test_split

# Initialize and train the XGBoost model for high price prediction
model_high = xgb.XGBRegressor(n_estimators=5, learning_rate=0.1, random_state=42)
model_high.fit(X_train, y_train_high)

# Initialize and train the XGBoost model for low price prediction
model_low = xgb.XGBRegressor(n_estimators=5, learning_rate=0.1, random_state=42)
model_low.fit(X_train, y_train_low)

# Predict on the test set
y_pred_high = model_high.predict(X_test)
y_pred_low = model_low.predict(X_test)

# Evaluate model performance
mae_high = mean_absolute_error(y_test_high, y_pred_high)
rmse_high = np.sqrt(mean_squared_error(y_test_high, y_pred_high))
mae_low = mean_absolute_error(y_test_low, y_pred_low)
rmse_low = np.sqrt(mean_squared_error(y_test_low, y_pred_low))

print(f"High Price Prediction - MAE: {mae_high}, RMSE: {rmse_high}")
print(f"Low Price Prediction - MAE: {mae_low}, RMSE: {rmse_low}")

# Calculate MAPE (Mean Absolute Percentage Error)
def mean_absolute_percentage_error(y_true, y_pred):
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

mape_high = mean_absolute_percentage_error(y_test_high, y_pred_high)
mape_low = mean_absolute_percentage_error(y_test_low, y_pred_low)

print(f"High Price Prediction - MAPE: {mape_high}%")
print(f"Low Price Prediction - MAPE: {mape_low}%")

# Calculate the R-squared (R²) score for both high and low price predictions
r2_high = r2_score(y_test_high, y_pred_high)
r2_low = r2_score(y_test_low, y_pred_low)

# Print all evaluation metrics
print(f"High Price Prediction - MAE: {mae_high}, RMSE: {rmse_high}, MAPE: {mape_high}%, R²: {r2_high}")
print(f"Low Price Prediction - MAE: {mae_low}, RMSE: {rmse_low}, MAPE: {mape_low}%, R²: {r2_low}")

# Feature importance from the XGBoost model
feature_importance_high = model_high.feature_importances_
feature_importance_low = model_low.feature_importances_

# Create a DataFrame for feature importance visualization
feature_importance_df_high = pd.DataFrame({
    'Feature': X.columns,
    'Importance': feature_importance_high
}).sort_values(by='Importance', ascending=False)

feature_importance_df_low = pd.DataFrame({
    'Feature': X.columns,
    'Importance': feature_importance_low
}).sort_values(by='Importance', ascending=False)

# Plot feature importance for high price prediction
plt.figure(figsize=(10, 6))
sns.barplot(x='Importance', y='Feature', data=feature_importance_df_high)
plt.title('Feature Importance for High Price Prediction')
plt.show()

# Plot feature importance for low price prediction
plt.figure(figsize=(10, 6))
sns.barplot(x='Importance', y='Feature', data=feature_importance_df_low)
plt.title('Feature Importance for Low Price Prediction')
plt.show()

import pandas as pd
import numpy as np

# Define the function to predict high and low prices in a given date range using XGBoost models
def predict_high_low_between_dates(df, model_high, model_low, start_date, end_date):
    # Convert start and end dates to datetime format
    start_date = pd.to_datetime(start_date)
    end_date = pd.to_datetime(end_date)

    # Generate the date range between start_date and end_date
    date_range = pd.date_range(start=start_date, end=end_date)

    # Get the last row of data (most recent available data)
    last_data = df.iloc[-1:]

    # Initialize lists to store predictions and dates
    predicted_prices_list = []

    # Track the most recent close price
    last_predicted_close = last_data['close'].values[0]

    # Iterate over the date range and predict the high and low for each day
    for future_date in date_range:
        # Prepare the features for the current date prediction
        features = last_data[['close', '7_day_avg', '30_day_avg', '7_day_volatility', 'close_lag_1', 'close_lag_5', 'close_lag_10', 'day_of_week', 'month', 'is_weekend']].copy()

        # Modify the future date-based features as required (e.g., month, day of the week)
        features['day_of_week'] = future_date.dayofweek
        features['month'] = future_date.month
        features['is_weekend'] = int(future_date.weekday() >= 5)  # 1 if weekend, 0 if weekday

        # Update lag features dynamically based on the most recent predicted close price
        features['close_lag_1'] = last_predicted_close  # Last predicted close price
        features['close_lag_5'] = df['close'].iloc[-5] if len(df) > 5 else last_predicted_close  # Last 5th day's close
        features['close_lag_10'] = df['close'].iloc[-10] if len(df) > 10 else last_predicted_close  # Last 10th day's close

        # Reshape the features to be 2D (for XGBoost model input)
        features_reshaped = features.values.reshape(1, -1)  # Reshape to 2D array: (1, num_features)

        # Predict the high and low prices for the next day using the trained XGBoost models
        predicted_high = model_high.predict(features_reshaped)[0]
        predicted_low = model_low.predict(features_reshaped)[0]

        # Append the predicted values with the corresponding future date
        predicted_prices_list.append({
            'date': future_date,
            'predicted_high': predicted_high,
            'predicted_low': predicted_low
        })

        # Update the last predicted close price for the next iteration
        last_predicted_close = predicted_high  # You can also use the predicted low if you prefer

    # Convert the list of predicted prices into a DataFrame
    predicted_prices = pd.DataFrame(predicted_prices_list)

    # Find the date with the highest predicted price
    highest_price_row = predicted_prices.loc[predicted_prices['predicted_high'].idxmax()]
    lowest_price_row = predicted_prices.loc[predicted_prices['predicted_low'].idxmin()]

    # Display the result with the exact date for the highest and lowest price
    print(f"In the given date range ({start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}), the highest price will be on {highest_price_row['date'].strftime('%Y-%m-%d')} with a price of {highest_price_row['predicted_high']:.2f}")
    print(f"In the given date range ({start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}), the lowest price will be on {lowest_price_row['date'].strftime('%Y-%m-%d')} with a price of {lowest_price_row['predicted_low']:.2f}")

# Example: Predict for the date range Dec 26, 2024 to Dec 30, 2024
predict_high_low_between_dates(df, model_high, model_low, start_date='2024-12-26', end_date='2024-12-30')